//
// DO NOT EDIT THIS FILE!
// It is automatically generated from opcfoundation.org schemas.
//

#include <string>
#include <sstream>
#include <iomanip>

#include "opc/ua/protocol/status_codes.h"

namespace OpcUa
{

std::string ToString(const StatusCode & code)
{
  if (code == StatusCode::Good)
    {
      return std::string();
    }

  std::stringstream stream;

  switch (code)
    {
    case StatusCode::BadUnexpectedError:
      stream << "An unexpected error occurred.";
      break;

    case StatusCode::BadInternalError:
      stream << "An internal error occurred as a result of a programming or configuration error.";
      break;

    case StatusCode::BadOutOfMemory:
      stream << "Not enough memory to complete the operation.";
      break;

    case StatusCode::BadResourceUnavailable:
      stream << "An operating system resource is not available.";
      break;

    case StatusCode::BadCommunicationError:
      stream << "A low level communication error occurred.";
      break;

    case StatusCode::BadEncodingError:
      stream << "Encoding halted because of invalid data in the objects being serialized.";
      break;

    case StatusCode::BadDecodingError:
      stream << "Decoding halted because of invalid data in the stream.";
      break;

    case StatusCode::BadEncodingLimitsExceeded:
      stream << "The message encoding/decoding limits imposed by the stack have been exceeded.";
      break;

    case StatusCode::BadRequestTooLarge:
      stream << "The request message size exceeds limits set by the server.";
      break;

    case StatusCode::BadResponseTooLarge:
      stream << "The response message size exceeds limits set by the client.";
      break;

    case StatusCode::BadUnknownResponse:
      stream << "An unrecognized response was received from the server.";
      break;

    case StatusCode::BadTimeout:
      stream << "The operation timed out.";
      break;

    case StatusCode::BadServiceUnsupported:
      stream << "The server does not support the requested service.";
      break;

    case StatusCode::BadShutdown:
      stream << "The operation was cancelled because the application is shutting down.";
      break;

    case StatusCode::BadServerNotConnected:
      stream << "The operation could not complete because the client is not connected to the server.";
      break;

    case StatusCode::BadServerHalted:
      stream << "The server has stopped and cannot process any requests.";
      break;

    case StatusCode::BadNothingToDo:
      stream << "There was nothing to do because the client passed a list of operations with no elements.";
      break;

    case StatusCode::BadTooManyOperations:
      stream << "The request could not be processed because it specified too many operations.";
      break;

    case StatusCode::BadTooManyMonitoredItems:
      stream << "The request could not be processed because there are too many monitored items in the subscription.";
      break;

    case StatusCode::BadDataTypeIdUnknown:
      stream << "The extension object cannot be (de)serialized because the data type id is not recognized.";
      break;

    case StatusCode::BadCertificateInvalid:
      stream << "The certificate provided as a parameter is not valid.";
      break;

    case StatusCode::BadSecurityChecksFailed:
      stream << "An error occurred verifying security.";
      break;

    case StatusCode::BadCertificateTimeInvalid:
      stream << "The Certificate has expired or is not yet valid.";
      break;

    case StatusCode::BadCertificateIssuerTimeInvalid:
      stream << "An Issuer Certificate has expired or is not yet valid.";
      break;

    case StatusCode::BadCertificateHostNameInvalid:
      stream << "The HostName used to connect to a Server does not match a HostName in the Certificate.";
      break;

    case StatusCode::BadCertificateUriInvalid:
      stream << "The URI specified in the ApplicationDescription does not match the URI in the Certificate.";
      break;

    case StatusCode::BadCertificateUseNotAllowed:
      stream << "The Certificate may not be used for the requested operation.";
      break;

    case StatusCode::BadCertificateIssuerUseNotAllowed:
      stream << "The Issuer Certificate may not be used for the requested operation.";
      break;

    case StatusCode::BadCertificateUntrusted:
      stream << "The Certificate is not trusted.";
      break;

    case StatusCode::BadCertificateRevocationUnknown:
      stream << "It was not possible to determine if the Certificate has been revoked.";
      break;

    case StatusCode::BadCertificateIssuerRevocationUnknown:
      stream << "It was not possible to determine if the Issuer Certificate has been revoked.";
      break;

    case StatusCode::BadCertificateRevoked:
      stream << "The Certificate has been revoked.";
      break;

    case StatusCode::BadCertificateIssuerRevoked:
      stream << "The Issuer Certificate has been revoked.";
      break;

    case StatusCode::BadUserAccessDenied:
      stream << "User does not have permission to perform the requested operation.";
      break;

    case StatusCode::BadIdentityTokenInvalid:
      stream << "The user identity token is not valid.";
      break;

    case StatusCode::BadIdentityTokenRejected:
      stream << "The user identity token is valid but the server has rejected it.";
      break;

    case StatusCode::BadSecureChannelIdInvalid:
      stream << "The specified secure channel is no longer valid.";
      break;

    case StatusCode::BadInvalidTimestamp:
      stream << "The timestamp is outside the range allowed by the server.";
      break;

    case StatusCode::BadNonceInvalid:
      stream << "The nonce does appear to be not a random value or it is not the correct length.";
      break;

    case StatusCode::BadSessionIdInvalid:
      stream << "The session id is not valid.";
      break;

    case StatusCode::BadSessionClosed:
      stream << "The session was closed by the client.";
      break;

    case StatusCode::BadSessionNotActivated:
      stream << "The session cannot be used because ActivateSession has not been called.";
      break;

    case StatusCode::BadSubscriptionIdInvalid:
      stream << "The subscription id is not valid.";
      break;

    case StatusCode::BadRequestHeaderInvalid:
      stream << "The header for the request is missing or invalid.";
      break;

    case StatusCode::BadTimestampsToReturnInvalid:
      stream << "The timestamps to return parameter is invalid.";
      break;

    case StatusCode::BadRequestCancelledByClient:
      stream << "The request was cancelled by the client.";
      break;

    case StatusCode::GoodSubscriptionTransferred:
      stream << "The subscription was transferred to another session.";
      break;

    case StatusCode::GoodCompletesAsynchronously:
      stream << "The processing will complete asynchronously.";
      break;

    case StatusCode::GoodOverload:
      stream << "Sampling has slowed down due to resource limitations.";
      break;

    case StatusCode::GoodClamped:
      stream << "The value written was accepted but was clamped.";
      break;

    case StatusCode::BadNoCommunication:
      stream << "Communication with the data source is defined";
      break;

    case StatusCode::BadWaitingForInitialData:
      stream << "Waiting for the server to obtain values from the underlying data source.";
      break;

    case StatusCode::BadNodeIdInvalid:
      stream << "The syntax of the node id is not valid.";
      break;

    case StatusCode::BadNodeIdUnknown:
      stream << "The node id refers to a node that does not exist in the server address space.";
      break;

    case StatusCode::BadAttributeIdInvalid:
      stream << "The attribute is not supported for the specified Node.";
      break;

    case StatusCode::BadIndexRangeInvalid:
      stream << "The syntax of the index range parameter is invalid.";
      break;

    case StatusCode::BadIndexRangeNoData:
      stream << "No data exists within the range of indexes specified.";
      break;

    case StatusCode::BadDataEncodingInvalid:
      stream << "The data encoding is invalid.";
      break;

    case StatusCode::BadDataEncodingUnsupported:
      stream << "The server does not support the requested data encoding for the node.";
      break;

    case StatusCode::BadNotReadable:
      stream << "The access level does not allow reading or subscribing to the Node.";
      break;

    case StatusCode::BadNotWritable:
      stream << "The access level does not allow writing to the Node.";
      break;

    case StatusCode::BadOutOfRange:
      stream << "The value was out of range.";
      break;

    case StatusCode::BadNotSupported:
      stream << "The requested operation is not supported.";
      break;

    case StatusCode::BadNotFound:
      stream << "A requested item was not found or a search operation ended without success.";
      break;

    case StatusCode::BadObjectDeleted:
      stream << "The object cannot be used because it has been deleted.";
      break;

    case StatusCode::BadNotImplemented:
      stream << "Requested operation is not implemented.";
      break;

    case StatusCode::BadMonitoringModeInvalid:
      stream << "The monitoring mode is invalid.";
      break;

    case StatusCode::BadMonitoredItemIdInvalid:
      stream << "The monitoring item id does not refer to a valid monitored item.";
      break;

    case StatusCode::BadMonitoredItemFilterInvalid:
      stream << "The monitored item filter parameter is not valid.";
      break;

    case StatusCode::BadMonitoredItemFilterUnsupported:
      stream << "The server does not support the requested monitored item filter.";
      break;

    case StatusCode::BadFilterNotAllowed:
      stream << "A monitoring filter cannot be used in combination with the attribute specified.";
      break;

    case StatusCode::BadStructureMissing:
      stream << "A mandatory structured parameter was missing or null.";
      break;

    case StatusCode::BadEventFilterInvalid:
      stream << "The event filter is not valid.";
      break;

    case StatusCode::BadContentFilterInvalid:
      stream << "The content filter is not valid.";
      break;

    case StatusCode::BadFilterOperatorInvalid:
      stream << "An unregognized operator was provided in a filter.";
      break;

    case StatusCode::BadFilterOperatorUnsupported:
      stream << "A valid operator was provided";
      break;

    case StatusCode::BadFilterOperandCountMismatch:
      stream << "The number of operands provided for the filter operator was less then expected for the operand provided.";
      break;

    case StatusCode::BadFilterOperandInvalid:
      stream << "The operand used in a content filter is not valid.";
      break;

    case StatusCode::BadFilterElementInvalid:
      stream << "The referenced element is not a valid element in the content filter.";
      break;

    case StatusCode::BadFilterLiteralInvalid:
      stream << "The referenced literal is not a valid value.";
      break;

    case StatusCode::BadContinuationPointInvalid:
      stream << "The continuation point provide is longer valid.";
      break;

    case StatusCode::BadNoContinuationPoints:
      stream << "The operation could not be processed because all continuation points have been allocated.";
      break;

    case StatusCode::BadReferenceTypeIdInvalid:
      stream << "The operation could not be processed because all continuation points have been allocated.";
      break;

    case StatusCode::BadBrowseDirectionInvalid:
      stream << "The browse direction is not valid.";
      break;

    case StatusCode::BadNodeNotInView:
      stream << "The node is not part of the view.";
      break;

    case StatusCode::BadServerUriInvalid:
      stream << "The ServerUri is not a valid URI.";
      break;

    case StatusCode::BadServerNameMissing:
      stream << "No ServerName was specified.";
      break;

    case StatusCode::BadDiscoveryUrlMissing:
      stream << "No DiscoveryUrl was specified.";
      break;

    case StatusCode::BadSempahoreFileMissing:
      stream << "The semaphore file specified by the client is not valid.";
      break;

    case StatusCode::BadRequestTypeInvalid:
      stream << "The security token request type is not valid.";
      break;

    case StatusCode::BadSecurityModeRejected:
      stream << "The security mode does not meet the requirements set by the Server.";
      break;

    case StatusCode::BadSecurityPolicyRejected:
      stream << "The security policy does not meet the requirements set by the Server.";
      break;

    case StatusCode::BadTooManySessions:
      stream << "The server has reached its maximum number of sessions.";
      break;

    case StatusCode::BadUserSignatureInvalid:
      stream << "The user token signature is missing or invalid.";
      break;

    case StatusCode::BadApplicationSignatureInvalid:
      stream << "The signature generated with the client certificate is missing or invalid.";
      break;

    case StatusCode::BadNoValidCertificates:
      stream << "The client did not provide at least one software certificate that is valid and meets the profile requirements for the server.";
      break;

    case StatusCode::BadIdentityChangeNotSupported:
      stream << "The Server does not support changing the user identity assigned to the session.";
      break;

    case StatusCode::BadRequestCancelledByRequest:
      stream << "The request was cancelled by the client with the Cancel service.";
      break;

    case StatusCode::BadParentNodeIdInvalid:
      stream << "The parent node id does not to refer to a valid node.";
      break;

    case StatusCode::BadReferenceNotAllowed:
      stream << "The reference could not be created because it violates constraints imposed by the data model.";
      break;

    case StatusCode::BadNodeIdRejected:
      stream << "The requested node id was reject because it was either invalid or server does not allow node ids to be specified by the client.";
      break;

    case StatusCode::BadNodeIdExists:
      stream << "The requested node id is already used by another node.";
      break;

    case StatusCode::BadNodeClassInvalid:
      stream << "The node class is not valid.";
      break;

    case StatusCode::BadBrowseNameInvalid:
      stream << "The browse name is invalid.";
      break;

    case StatusCode::BadBrowseNameDuplicated:
      stream << "The browse name is not unique among nodes that share the same relationship with the parent.";
      break;

    case StatusCode::BadNodeAttributesInvalid:
      stream << "The node attributes are not valid for the node class.";
      break;

    case StatusCode::BadTypeDefinitionInvalid:
      stream << "The type definition node id does not reference an appropriate type node.";
      break;

    case StatusCode::BadSourceNodeIdInvalid:
      stream << "The source node id does not reference a valid node.";
      break;

    case StatusCode::BadTargetNodeIdInvalid:
      stream << "The target node id does not reference a valid node.";
      break;

    case StatusCode::BadDuplicateReferenceNotAllowed:
      stream << "The reference type between the nodes is already defined.";
      break;

    case StatusCode::BadInvalidSelfReference:
      stream << "The server does not allow this type of self reference on this node.";
      break;

    case StatusCode::BadReferenceLocalOnly:
      stream << "The reference type is not valid for a reference to a remote server.";
      break;

    case StatusCode::BadNoDeleteRights:
      stream << "The server will not allow the node to be deleted.";
      break;

    case StatusCode::UncertainReferenceNotDeleted:
      stream << "The server was not able to delete all target references.";
      break;

    case StatusCode::BadServerIndexInvalid:
      stream << "The server index is not valid.";
      break;

    case StatusCode::BadViewIdUnknown:
      stream << "The view id does not refer to a valid view node.";
      break;

    case StatusCode::BadViewTimestampInvalid:
      stream << "The view timestamp is not available or not supported.";
      break;

    case StatusCode::BadViewParameterMismatch:
      stream << "The view parameters are not consistent with each other.";
      break;

    case StatusCode::BadViewVersionInvalid:
      stream << "The view version is not available or not supported.";
      break;

    case StatusCode::UncertainNotAllNodesAvailable:
      stream << "The list of references may not be complete because the underlying system is not available.";
      break;

    case StatusCode::GoodResultsMayBeIncomplete:
      stream << "The server should have followed a reference to a node in a remote server but did not. The result set may be incomplete.";
      break;

    case StatusCode::BadNotTypeDefinition:
      stream << "The provided Nodeid was not a type definition nodeid.";
      break;

    case StatusCode::UncertainReferenceOutOfServer:
      stream << "One of the references to follow in the relative path references to a node in the address space in another server.";
      break;

    case StatusCode::BadTooManyMatches:
      stream << "The requested operation has too many matches to return.";
      break;

    case StatusCode::BadQueryTooComplex:
      stream << "The requested operation requires too many resources in the server.";
      break;

    case StatusCode::BadNoMatch:
      stream << "The requested operation has no match to return.";
      break;

    case StatusCode::BadMaxAgeInvalid:
      stream << "The max age parameter is invalid.";
      break;

    case StatusCode::BadHistoryOperationInvalid:
      stream << "The history details parameter is not valid.";
      break;

    case StatusCode::BadHistoryOperationUnsupported:
      stream << "The server does not support the requested operation.";
      break;

    case StatusCode::BadInvalidTimestampArgument:
      stream << "The defined timestamp to return was invalid.";
      break;

    case StatusCode::BadWriteNotSupported:
      stream << "The server not does support writing the combination of value";
      break;

    case StatusCode::BadTypeMismatch:
      stream << "The value supplied for the attribute is not of the same type as the attribute's value.";
      break;

    case StatusCode::BadMethodInvalid:
      stream << "The method id does not refer to a method for the specified object.";
      break;

    case StatusCode::BadArgumentsMissing:
      stream << "The client did not specify all of the input arguments for the method.";
      break;

    case StatusCode::BadTooManySubscriptions:
      stream << "The server has reached its  maximum number of subscriptions.";
      break;

    case StatusCode::BadTooManyPublishRequests:
      stream << "The server has reached the maximum number of queued publish requests.";
      break;

    case StatusCode::BadNoSubscription:
      stream << "There is no subscription available for this session.";
      break;

    case StatusCode::BadSequenceNumberUnknown:
      stream << "The sequence number is unknown to the server.";
      break;

    case StatusCode::BadMessageNotAvailable:
      stream << "The requested notification message is no longer available.";
      break;

    case StatusCode::BadInsufficientClientProfile:
      stream << "The Client of the current Session does not support one or more Profiles that are necessary for the Subscription.";
      break;

    case StatusCode::BadStateNotActive:
      stream << "The sub-state machine is not currently active.";
      break;

    case StatusCode::BadTcpServerTooBusy:
      stream << "The server cannot process the request because it is too busy.";
      break;

    case StatusCode::BadTcpMessageTypeInvalid:
      stream << "The type of the message specified in the header invalid.";
      break;

    case StatusCode::BadTcpSecureChannelUnknown:
      stream << "The SecureChannelId and/or TokenId are not currently in use.";
      break;

    case StatusCode::BadTcpMessageTooLarge:
      stream << "The size of the message specified in the header is too large.";
      break;

    case StatusCode::BadTcpNotEnoughResources:
      stream << "There are not enough resources to process the request.";
      break;

    case StatusCode::BadTcpInternalError:
      stream << "An internal error occurred.";
      break;

    case StatusCode::BadTcpEndpointUrlInvalid:
      stream << "The Server does not recognize the QueryString specified.";
      break;

    case StatusCode::BadRequestInterrupted:
      stream << "The request could not be sent because of a network interruption.";
      break;

    case StatusCode::BadRequestTimeout:
      stream << "Timeout occurred while processing the request.";
      break;

    case StatusCode::BadSecureChannelClosed:
      stream << "The secure channel has been closed.";
      break;

    case StatusCode::BadSecureChannelTokenUnknown:
      stream << "The token has expired or is not recognized.";
      break;

    case StatusCode::BadSequenceNumberInvalid:
      stream << "The sequence number is not valid.";
      break;

    case StatusCode::BadProtocolVersionUnsupported:
      stream << "The applications do not have compatible protocol versions.";
      break;

    case StatusCode::BadConfigurationError:
      stream << "There is a problem with the configuration that affects the usefulness of the value.";
      break;

    case StatusCode::BadNotConnected:
      stream << "The variable should receive its value from another variable";
      break;

    case StatusCode::BadDeviceFailure:
      stream << "There has been a failure in the device/data source that generates the value that has affected the value.";
      break;

    case StatusCode::BadSensorFailure:
      stream << "There has been a failure in the sensor from which the value is derived by the device/data source.";
      break;

    case StatusCode::BadOutOfService:
      stream << "The source of the data is not operational.";
      break;

    case StatusCode::BadDeadbandFilterInvalid:
      stream << "The deadband filter is not valid.";
      break;

    case StatusCode::UncertainNoCommunicationLastUsableValue:
      stream << "Communication to the data source has failed. The variable value is the last value that had a good quality.";
      break;

    case StatusCode::UncertainLastUsableValue:
      stream << "Whatever was updating this value has stopped doing so.";
      break;

    case StatusCode::UncertainSubstituteValue:
      stream << "The value is an operational value that was manually overwritten.";
      break;

    case StatusCode::UncertainInitialValue:
      stream << "The value is an initial value for a variable that normally receives its value from another variable.";
      break;

    case StatusCode::UncertainSensorNotAccurate:
      stream << "The value is at one of the sensor limits.";
      break;

    case StatusCode::UncertainEngineeringUnitsExceeded:
      stream << "The value is outside of the range of values defined for this parameter.";
      break;

    case StatusCode::UncertainSubNormal:
      stream << "The value is derived from multiple sources and has less than the required number of Good sources.";
      break;

    case StatusCode::GoodLocalOverride:
      stream << "The value has been overridden.";
      break;

    case StatusCode::BadRefreshInProgress:
      stream << "This Condition refresh failed";
      break;

    case StatusCode::BadConditionAlreadyDisabled:
      stream << "This condition has already been disabled.";
      break;

    case StatusCode::BadConditionAlreadyEnabled:
      stream << "This condition has already been enabled.";
      break;

    case StatusCode::BadConditionDisabled:
      stream << "Property not available";
      break;

    case StatusCode::BadEventIdUnknown:
      stream << "The specified event id is not recognized.";
      break;

    case StatusCode::BadEventNotAcknowledgeable:
      stream << "The event cannot be acknowledged.";
      break;

    case StatusCode::BadDialogNotActive:
      stream << "The dialog condition is not active.";
      break;

    case StatusCode::BadDialogResponseInvalid:
      stream << "The response is not valid for the dialog.";
      break;

    case StatusCode::BadConditionBranchAlreadyAcked:
      stream << "The condition branch has already been acknowledged.";
      break;

    case StatusCode::BadConditionBranchAlreadyConfirmed:
      stream << "The condition branch has already been confirmed.";
      break;

    case StatusCode::BadConditionAlreadyShelved:
      stream << "The condition has already been shelved.";
      break;

    case StatusCode::BadConditionNotShelved:
      stream << "The condition is not currently shelved.";
      break;

    case StatusCode::BadShelvingTimeOutOfRange:
      stream << "The shelving time not within an acceptable range.";
      break;

    case StatusCode::BadNoData:
      stream << "No data exists for the requested time range or event filter.";
      break;

    case StatusCode::BadBoundNotFound:
      stream << "No data found to provide upper or lower bound value.";
      break;

    case StatusCode::BadBoundNotSupported:
      stream << "The server cannot retrieve a bound for the variable.";
      break;

    case StatusCode::BadDataLost:
      stream << "Data is missing due to collection started/stopped/lost.";
      break;

    case StatusCode::BadDataUnavailable:
      stream << "Expected data is unavailable for the requested time range due to an un-mounted volume";
      break;

    case StatusCode::BadEntryExists:
      stream << "The data or event was not successfully inserted because a matching entry exists.";
      break;

    case StatusCode::BadNoEntryExists:
      stream << "The data or event was not successfully updated because no matching entry exists.";
      break;

    case StatusCode::BadTimestampNotSupported:
      stream << "The client requested history using a timestamp format the server does not support (i.e requested ServerTimestamp when server only supports SourceTimestamp).";
      break;

    case StatusCode::GoodEntryInserted:
      stream << "The data or event was successfully inserted into the historical database.";
      break;

    case StatusCode::GoodEntryReplaced:
      stream << "The data or event field was successfully replaced in the historical database.";
      break;

    case StatusCode::UncertainDataSubNormal:
      stream << "The value is derived from multiple values and has less than the required number of Good values.";
      break;

    case StatusCode::GoodNoData:
      stream << "No data exists for the requested time range or event filter.";
      break;

    case StatusCode::GoodMoreData:
      stream << "The data or event field was successfully replaced in the historical database.";
      break;

    case StatusCode::BadAggregateListMismatch:
      stream << "The requested number of Aggregates does not match the requested number of NodeIds.";
      break;

    case StatusCode::BadAggregateNotSupported:
      stream << "The requested Aggregate is not support by the server.";
      break;

    case StatusCode::BadAggregateInvalidInputs:
      stream << "The aggregate value could not be derived due to invalid data inputs.";
      break;

    case StatusCode::BadAggregateConfigurationRejected:
      stream << "The aggregate configuration is not valid for specified node.";
      break;

    case StatusCode::GoodDataIgnored:
      stream << "The request pecifies fields which are not valid for the EventType or cannot be saved by the historian.";
      break;

    case StatusCode::GoodCommunicationEvent:
      stream << "The communication layer has raised an event.";
      break;

    case StatusCode::GoodShutdownEvent:
      stream << "The system is shutting down.";
      break;

    case StatusCode::GoodCallAgain:
      stream << "The operation is not finished and needs to be called again.";
      break;

    case StatusCode::GoodNonCriticalTimeout:
      stream << "A non-critical timeout occurred.";
      break;

    case StatusCode::BadInvalidArgument:
      stream << "One or more arguments are invalid.";
      break;

    case StatusCode::BadConnectionRejected:
      stream << "Could not establish a network connection to remote server.";
      break;

    case StatusCode::BadDisconnect:
      stream << "The server has disconnected from the client.";
      break;

    case StatusCode::BadConnectionClosed:
      stream << "The network connection has been closed.";
      break;

    case StatusCode::BadInvalidState:
      stream << "The operation cannot be completed because the object is closed";
      break;

    case StatusCode::BadEndOfStream:
      stream << "Cannot move beyond end of the stream.";
      break;

    case StatusCode::BadNoDataAvailable:
      stream << "No data is currently available for reading from a non-blocking stream.";
      break;

    case StatusCode::BadWaitingForResponse:
      stream << "The asynchronous operation is waiting for a response.";
      break;

    case StatusCode::BadOperationAbandoned:
      stream << "The asynchronous operation was abandoned by the caller.";
      break;

    case StatusCode::BadExpectedStreamToBlock:
      stream << "The stream did not return all data requested (possibly because it is a non-blocking stream).";
      break;

    case StatusCode::BadWouldBlock:
      stream << "Non blocking behaviour is required and the operation would block.";
      break;

    case StatusCode::BadSyntaxError:
      stream << "A value had an invalid syntax.";
      break;

    case StatusCode::BadMaxConnectionsReached:
      stream << "The operation could not be finished because all available connections are in use.";
      break;

    default:
      stream << "Unknown StatusCode?";
      break;
    }

  stream << " (0x" << std::setfill('0') << std::setw(8) << std::hex << (unsigned)code << ")";

  return stream.str();
}

} // namespace OpcUa

